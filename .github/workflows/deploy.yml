name: Build & Deploy Docker to aurigraph.io

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: aurigraph-dlt-corp/aurigraph-website
  SSH_USER: subbu
  SSH_HOST: aurigraph.io
  SSH_PORT: 22
  APP_DIR: ~/aurigraph-website
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: ‚úÖ Checkout code
        uses: actions/checkout@v4

      - name: ‚úÖ Setup Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: üîê Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üèóÔ∏è Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max

  deploy:
    needs: build-and-push
    runs-on: self-hosted
    env:
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
      DOCKER_TOKEN: ${{ secrets.DOCKER_REGISTRY_TOKEN }}
      GITHUB_ACTOR: ${{ github.actor }}

    steps:
      - name: ‚öôÔ∏è Configure Git for Deployment
        run: |
          git config --global user.email "deployment@aurigraph.io"
          git config --global user.name "Aurigraph Deployment"
          echo "‚úì Git configured"

      - name: ‚úÖ Checkout code (via HTTPS)
        run: |
          # Initialize git repo and pull latest code
          if [ ! -d .git ]; then
            echo "Initializing fresh repository..."
            git init
            git remote add origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/Aurigraph-DLT-Corp/aurigraph-website.git
            git fetch origin "$GITHUB_SHA"
            git reset --hard "$GITHUB_SHA"
          else
            echo "Repository exists, pulling latest..."
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/Aurigraph-DLT-Corp/aurigraph-website.git
            git fetch origin
            git reset --hard "$GITHUB_SHA"
          fi

          echo "‚úì Repository ready: $(git rev-parse --short HEAD)"

      - name: üìÅ Prepare Deployment Files
        run: |
          # Copy deployment files to app directory (self-hosted runner is already on server)
          # Note: Use $HOME instead of ~ to ensure proper path expansion
          APP_DIR="$HOME/aurigraph-website"
          mkdir -p $APP_DIR
          mkdir -p $APP_DIR/scripts

          echo "üìã Copying deployment files to $APP_DIR..."
          cp docker-compose.production.yml $APP_DIR/ 2>/dev/null || true
          cp nginx.conf $APP_DIR/ 2>/dev/null || true
          cp .env.production $APP_DIR/ 2>/dev/null || true
          cp scripts/init-db.sql $APP_DIR/scripts/ 2>/dev/null || true

          echo "‚úÖ Files copied successfully"
          ls -la $APP_DIR/

          # Export APP_DIR for next step
          echo "APP_DIR=$APP_DIR" >> $GITHUB_ENV

      - name: üöÄ Deploy to Production (Direct Execution)
        run: |
          # Since self-hosted runner is on the server, run docker commands directly
          cd $APP_DIR
          set -e

          echo "=== DEPLOYMENT STARTED ==="

          echo "Authenticating with GitHub Container Registry..."
          echo "$DOCKER_TOKEN" | docker login ghcr.io -u "$GITHUB_ACTOR" --password-stdin

          echo "üê≥ Pulling latest Docker image..."
          docker pull "$REGISTRY/$IMAGE_NAME:latest"

          echo "üõë Stopping and removing old deployment..."
          docker compose -f docker-compose.production.yml down --remove-orphans --volumes 2>/dev/null || true

          # Wait for the stack to fully stop
          echo "‚è≥ Waiting for containers to stop (15 seconds)..."
          sleep 15

          # Remove any leftover containers by name
          echo "üßπ Force removing containers..."
          docker rm -f aurigraph-website aurigraph-db aurigraph-nginx 2>/dev/null || true

          # Remove the network explicitly
          echo "üßπ Removing Docker network..."
          docker network rm aurigraph-network 2>/dev/null || true

          # Wait for network cleanup to propagate
          sleep 10

          # Kill any processes still listening on the target ports
          echo "üîç Clearing processes on target ports..."
          for PORT in 3000 3001 3010 3011; do
            PIDS=$(lsof -Pi :$PORT -sTCP:LISTEN -t 2>/dev/null || true)
            if [ ! -z "$PIDS" ]; then
              echo "‚ö†Ô∏è  Killing processes on port $PORT: $PIDS"
              echo "$PIDS" | xargs kill -9 2>/dev/null || true
            fi
          done

          sleep 5

          # System prune to clean up unreferenced images and volumes
          echo "üßπ Docker system cleanup..."
          docker system prune -af --volumes 2>/dev/null || true

          # Final port status check
          echo "‚úÖ Verifying ports are free..."
          for PORT in 3000 3001 3010 3011 5432 80 443; do
            if netstat -tlnp 2>/dev/null | grep -q ":$PORT "; then
              echo "‚ö†Ô∏è  Port $PORT still in use - will retry"
            else
              echo "‚úì Port $PORT is free"
            fi
          done

          echo "üöÄ Starting containers..."
          DB_PASSWORD="$DB_PASSWORD" \
          NEXTAUTH_SECRET="$NEXTAUTH_SECRET" \
          docker compose -f docker-compose.production.yml up -d

          echo "‚è≥ Waiting for services to be healthy..."
          sleep 5

          echo "‚úÖ Verifying containers..."
          docker compose -f docker-compose.production.yml ps

          echo "=== DEPLOYMENT COMPLETED ==="
        env:
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          DOCKER_TOKEN: ${{ env.DOCKER_TOKEN }}
          GITHUB_ACTOR: ${{ env.GITHUB_ACTOR }}
          DB_PASSWORD: ${{ env.DB_PASSWORD }}
          NEXTAUTH_SECRET: ${{ env.NEXTAUTH_SECRET }}

      - name: ‚úÖ Verify Deployment Success
        if: success()
        run: |
          echo "üéâ Deployment completed successfully!"
          echo "Services running on aurigraph.io:"
          docker compose -f "${{ env.APP_DIR }}/docker-compose.production.yml" ps

      - name: üéâ Deployment Success
        if: success()
        run: |
          cat << 'SUCCESS'
          ‚úÖ Docker deployment to https://aurigraph.io successful!

          Services deployed:
            üêò PostgreSQL 16 - Database container
            üöÄ Next.js App - Application container
            üåê NGINX Alpine - Reverse proxy container

          Access your site: https://aurigraph.io
          View logs: docker-compose -f ~/aurigraph-website/docker-compose.production.yml logs -f
          SUCCESS

      - name: ‚ùå Deployment Failed
        if: failure()
        run: |
          cat << 'FAILURE'
          ‚ùå Deployment failed

          Debug steps:
            ssh subbu@aurigraph.io
            cd ~/aurigraph-website
            docker-compose -f docker-compose.production.yml logs -f
          FAILURE
