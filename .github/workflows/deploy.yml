name: Build & Deploy Docker to aurigraph.io

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: aurigraph-dlt-corp/aurigraph-website
  SSH_USER: subbu
  SSH_HOST: aurigraph.io
  SSH_PORT: 22
  APP_DIR: ~/aurigraph-website
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: ‚úÖ Checkout code
        uses: actions/checkout@v4

      - name: ‚úÖ Setup Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: üîê Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üèóÔ∏è Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max

  deploy:
    needs: build-and-push
    runs-on: [ self-hosted, aurigraph ]
    env:
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
      DOCKER_TOKEN: ${{ secrets.DOCKER_REGISTRY_TOKEN }}
      GITHUB_ACTOR: ${{ github.actor }}

    steps:
      - name: ‚öôÔ∏è Configure Git for Deployment
        run: |
          git config --global user.email "deployment@aurigraph.io"
          git config --global user.name "Aurigraph Deployment"
          echo "‚úì Git configured"

      - name: ‚úÖ Checkout code (via HTTPS)
        run: |
          # Initialize git repo and pull latest code
          if [ ! -d .git ]; then
            echo "Initializing fresh repository..."
            git init
            git remote add origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/Aurigraph-DLT-Corp/aurigraph-website.git
            git fetch origin "$GITHUB_SHA"
            git reset --hard "$GITHUB_SHA"
          else
            echo "Repository exists, pulling latest..."
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/Aurigraph-DLT-Corp/aurigraph-website.git
            git fetch origin
            git reset --hard "$GITHUB_SHA"
          fi

          echo "‚úì Repository ready: $(git rev-parse --short HEAD)"

      - name: üìÅ Prepare Deployment Files
        run: |
          # Copy deployment files to app directory (self-hosted runner is already on server)
          # Note: Use $HOME instead of ~ to ensure proper path expansion
          APP_DIR="$HOME/aurigraph-website"
          mkdir -p $APP_DIR
          mkdir -p $APP_DIR/scripts

          echo "üìã Copying deployment files to $APP_DIR..."
          cp docker-compose.production.yml $APP_DIR/ 2>/dev/null || true
          cp nginx.conf $APP_DIR/ 2>/dev/null || true
          cp .env.production $APP_DIR/ 2>/dev/null || true
          cp scripts/init-db.sql $APP_DIR/scripts/ 2>/dev/null || true

          echo "‚úÖ Files copied successfully"
          ls -la $APP_DIR/

          # Export APP_DIR for next step
          echo "APP_DIR=$APP_DIR" >> $GITHUB_ENV

      - name: üöÄ Deploy to Production (Direct Execution)
        run: |
          # Since self-hosted runner is on the server, run docker commands directly
          cd $APP_DIR
          set -e

          echo "=== DEPLOYMENT STARTED ==="

          echo "Authenticating with GitHub Container Registry..."
          echo "$DOCKER_TOKEN" | docker login ghcr.io -u "$GITHUB_ACTOR" --password-stdin

          echo "üê≥ Pulling latest Docker image..."
          docker pull "$REGISTRY/$IMAGE_NAME:latest"

          echo "üõë Stopping and removing old deployment..."
          docker compose -f docker-compose.production.yml down --remove-orphans --volumes 2>/dev/null || true

          # Force remove the containers immediately
          echo "üßπ Force removing containers by name..."
          docker rm -f aurigraph-website aurigraph-db aurigraph-nginx 2>/dev/null || true

          # Explicitly remove the network
          echo "üßπ Removing Docker network..."
          docker network rm aurigraph-network 2>/dev/null || true

          # System prune first to clean up everything
          echo "üßπ Initial Docker system cleanup..."
          docker system prune -af --volumes 2>/dev/null || true

          # Wait for Docker to stabilize (60 seconds - give kernel time to release ports)
          echo "‚è≥ Waiting 60 seconds for full system stabilization..."
          sleep 60

          # Verify containers are actually gone
          echo "üîç Verifying old containers are removed..."
          for CONTAINER in aurigraph-website aurigraph-db aurigraph-nginx; do
            if docker inspect $CONTAINER 2>/dev/null | grep -q "\"Id\""; then
              echo "‚ö†Ô∏è  Container $CONTAINER still exists, force removing..."
              docker rm -f $CONTAINER 2>/dev/null || true
            else
              echo "‚úì Container $CONTAINER is gone"
            fi
          done

          # Kill any lingering processes on target ports
          echo "üîç Clearing any processes on target ports..."
          for PORT in 3000 3001 3010 3011; do
            PIDS=$(lsof -Pi :$PORT -sTCP:LISTEN -t 2>/dev/null || true)
            if [ ! -z "$PIDS" ]; then
              echo "‚ö†Ô∏è  Killing processes on port $PORT: $PIDS"
              echo "$PIDS" | xargs kill -9 2>/dev/null || true
              sleep 2
            fi
          done

          # Final comprehensive port check
          echo "‚úÖ Final port status verification..."
          for PORT in 3000 3001 3010 3011 5432 80 443; do
            if netstat -tlnp 2>/dev/null | grep -q ":$PORT "; then
              echo "‚ö†Ô∏è‚ö†Ô∏è Port $PORT is STILL IN USE - this will cause deployment to fail!"
            else
              echo "‚úì Port $PORT is free"
            fi
          done

          echo "üîÑ Restarting Docker daemon for clean internal state..."
          sudo systemctl restart docker 2>/dev/null || sudo service docker restart 2>/dev/null || true
          echo "‚è≥ Waiting for Docker to fully restart (15 seconds)..."
          sleep 15

          # Verify Docker is responsive
          echo "üîç Verifying Docker is responsive..."
          for i in {1..10}; do
            if docker ps >/dev/null 2>&1; then
              echo "‚úì Docker daemon is responsive"
              break
            fi
            echo "‚è≥ Waiting for Docker... (attempt $i/10)"
            sleep 2
          done

          echo "üöÄ Creating Docker network..."
          docker network create aurigraph-network 2>/dev/null || true

          echo "üöÄ Starting database container..."
          docker run -d \
            --name aurigraph-db \
            --network aurigraph-network \
            -e POSTGRES_USER=aurigraph \
            -e "POSTGRES_PASSWORD=$DB_PASSWORD" \
            -e POSTGRES_DB=aurigraph_website \
            -p 5433:5432 \
            -v aurigraph-db_data:/var/lib/postgresql/data \
            --restart always \
            postgres:16-alpine

          echo "‚è≥ Waiting for database to be ready..."
          # Active health check instead of fixed sleep - reduces race window
          for i in {1..20}; do
            if docker exec aurigraph-db pg_isready -U aurigraph >/dev/null 2>&1; then
              echo "‚úì Database is ready"
              break
            fi
            echo "‚è≥ Database not ready yet (attempt $i/20)..."
            sleep 1.5
          done

          # PRE-FLIGHT: Aggressive port 3000 check immediately before app container
          echo "üîç PRE-FLIGHT CHECK: Port 3000 status before app container start..."
          if netstat -tlnp 2>/dev/null | grep -q ":3000 "; then
            echo "‚ö†Ô∏è‚ö†Ô∏è RACE CONDITION DETECTED: Port 3000 IS IN USE - investigating..."
            echo "üîç Detailed port 3000 status:"
            netstat -tlnp 2>/dev/null | grep ":3000" || true
            echo "üîç Process list for port 3000:"
            lsof -i :3000 2>/dev/null || netstat -tlnp 2>/dev/null | grep ":3000" || true
            echo "üîç Docker containers status:"
            docker ps --all || true
            echo "üîç All processes listening on ports 3000-3010:"
            netstat -tlnp 2>/dev/null | grep -E ":(3000|3001|3002|3003|3004|3005|3006|3007|3008|3009|3010)" || true

            # Kill anything using port 3000
            echo "üßπ Force killing anything on port 3000..."
            PIDS=$(lsof -Pi :3000 -sTCP:LISTEN -t 2>/dev/null || true)
            if [ ! -z "$PIDS" ]; then
              echo "Killing PIDs: $PIDS"
              echo "$PIDS" | xargs kill -9 2>/dev/null || true
              sleep 3
            fi
          else
            echo "‚úì Port 3000 confirmed free for app container"
          fi

          echo "üöÄ Starting Next.js app container..."
          docker run -d \
            --name aurigraph-website \
            --network aurigraph-network \
            -e NODE_ENV=production \
            -e "DATABASE_URL=postgresql://aurigraph:$DB_PASSWORD@aurigraph-db:5432/aurigraph_website" \
            -e NEXTAUTH_URL=https://aurigraph.io \
            -e "NEXTAUTH_SECRET=$NEXTAUTH_SECRET" \
            -p 3000:3000 \
            --restart always \
            ghcr.io/aurigraph-dlt-corp/aurigraph-website:latest

          echo "‚è≥ Waiting for app to start (10 seconds)..."
          sleep 10

          echo "üöÄ Starting NGINX reverse proxy..."
          docker run -d \
            --name aurigraph-nginx \
            --network aurigraph-network \
            -p 8081:80 \
            -p 8443:443 \
            -v $APP_DIR/nginx.conf:/etc/nginx/nginx.conf:ro \
            -v /etc/letsencrypt:/etc/letsencrypt:ro \
            --restart always \
            nginx:alpine

          echo "‚è≥ Waiting for services to stabilize (10 seconds)..."
          sleep 10

          echo "‚úÖ Verifying containers..."
          docker ps --filter network=aurigraph-network

          echo "=== DEPLOYMENT COMPLETED ==="
        env:
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          DOCKER_TOKEN: ${{ env.DOCKER_TOKEN }}
          GITHUB_ACTOR: ${{ env.GITHUB_ACTOR }}
          DB_PASSWORD: ${{ env.DB_PASSWORD }}
          NEXTAUTH_SECRET: ${{ env.NEXTAUTH_SECRET }}

      - name: ‚úÖ Verify Deployment Success
        if: success()
        run: |
          echo "üéâ Deployment completed successfully!"
          echo "Services running on aurigraph.io:"
          docker compose -f "${{ env.APP_DIR }}/docker-compose.production.yml" ps

      - name: üéâ Deployment Success
        if: success()
        run: |
          cat << 'SUCCESS'
          ‚úÖ Docker deployment to https://aurigraph.io successful!

          Services deployed:
            üêò PostgreSQL 16 - Database container
            üöÄ Next.js App - Application container
            üåê NGINX Alpine - Reverse proxy container

          Access your site: https://aurigraph.io
          View logs: docker-compose -f ~/aurigraph-website/docker-compose.production.yml logs -f
          SUCCESS

      - name: ‚ùå Deployment Failed
        if: failure()
        run: |
          cat << 'FAILURE'
          ‚ùå Deployment failed

          Debug steps:
            ssh subbu@aurigraph.io
            cd ~/aurigraph-website
            docker-compose -f docker-compose.production.yml logs -f
          FAILURE
